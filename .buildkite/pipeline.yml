env:
  JULIA_VERSION: "1.12.4"
  JULIA_VERSION_ENZYME: "1.10.10"
  BUILDKITE_HOME: "/var/lib/buildkite-agent"
  JULIA_DEPOT_PATH: "$BUILDKITE_HOME/.julia-oceananigans"
  JULIA_PKG_SERVER_REGISTRY_PREFERENCE: eager
  XLA_REACTANT_GPU_PREALLOCATE: false
  OCEANANIGANS_DIR: "$HOME/Oceananigans.jl-$BUILDKITE_BUILD_NUMBER"

agents:
  queue: "Oceananigans"
with:
  coverage: false

steps:
  - label: "ðŸ•ï¸ initialize general environment"
    key: "init"
    agents:
      queue: "Oceananigans-nautilus"
    env:
      TEST_GROUP: "init"
    command: |
      juliaup add $JULIA_VERSION

      mkdir -p "$OCEANANIGANS_DIR"
      rsync -a . "$OCEANANIGANS_DIR/"
      cd "$OCEANANIGANS_DIR"

      julia +$JULIA_VERSION -O0 --color=yes --project -e 'using Pkg; Pkg.test()'
      # After we have instantiated the general environment, move manifest to the
      # version-specific filename, not to clash with the manifest for Enzyme.
      mv -v Manifest.toml Manifest-v$(echo "${JULIA_VERSION}" | cut -d. -f1-2).toml
    retry:
      automatic:
        - exit_status: 1
          limit: 1

  - label: "ðŸ•ï¸ initialize enzyme environment"
    key: "init_enzyme"
    depends_on: "init"
    agents:
      queue: "Oceananigans-nautilus"
    env:
      TEST_GROUP: "init"
    command: |
      juliaup add $JULIA_VERSION_ENZYME
      cd "$OCEANANIGANS_DIR"

      julia +$JULIA_VERSION_ENZYME -O0 --color=yes --project --code-coverage=user -e 'using Pkg; Pkg.test(coverage="user")''
      # After we have instantiated the Enzyme environment, move manifest to the
      # version-specific filename, not to clash with the general manifest.
      # mv -v Manifest.toml Manifest-v$(echo "${JULIA_VERSION_ENZYME}" | cut -d. -f1-2).toml
    retry:
      automatic:
        - exit_status: 1
          limit: 1

  - label: "ðŸ¦‰ documentation"
    depends_on: "init"
    agents:
      queue: "Oceananigans-nautilus"
    env:
      CUDA_VISIBLE_DEVICES: "0" # GPU for docs
    command: |
      cd "$OCEANANIGANS_DIR"
      julia +$JULIA_VERSION --color=yes --project=docs/ -e \
        'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'
      julia +$JULIA_VERSION --color=yes --project=docs/ docs/make.jl

  - label: "{{ matrix.architecture }} - {{ matrix.group }} tests"
    key: "tests"
    depends_on: "init"
    agents:
      queue: "Oceananigans-nautilus"
    command: |
      # Add matrix-specific environment variables
      if [[ "{{ matrix.architecture }}" == "CPU" ]]; then
        export CUDA_VISIBLE_DEVICES="-1"
        export TEST_ARCHITECTURE="CPU"
      else
        export CUDA_VISIBLE_DEVICES="0"
        export TEST_ARCHITECTURE="GPU"
      fi

      # Strip emoji for environment variable
      group="{{ matrix.group }}"
      export TEST_GROUP="\${group#* }"
      echo $TEST_GROUP

      # Run tests (but don't exit immediately so we can upload coverage even if tests fail)
      set +e
      julia +$JULIA_VERSION -O0 --color=yes --project --code-coverage=user -e 'using Pkg; Pkg.test(coverage="user")'
      test_status=$$?
      set -e

      # Sanity check: did we actually produce coverage?
      echo "Coverage files produced:" $$(find . -name "*.cov" | wc -l)
      find . -name "*.cov" | head -n 20 || true

      # Ship coverage files
      cd "$OCEANANIGANS_DIR"

      echo "PWD for coverage:"; pwd
      echo "Example cov files:"; find . -type f -name "*.cov" | head -n 20 || true

      tarball="coverage-${BUILDKITE_JOB_ID}.tgz"
      echo "Tarball will be: $tarball"

      # Create tarball directly from find output (newline-delimited)
      # This avoids --null / --files-from / covfiles.txt entirely.
      find . -type f -name "*.cov" -print > cov_list.txt
      echo "Coverage files found:" $(wc -l < cov_list.txt)
      head -n 20 cov_list.txt || true

      # If none, donâ€™t fail the step (but print why)
      if [ ! -s cov_list.txt ]; then
        echo "No .cov files found at tar time (but you printed some earlier)."
        exit 1
      fi

      tar -czf "$tarball" -T cov_list.txt

      # Upload single artifact
      buildkite-agent artifact upload "$tarball"

      # Preserve the original test result for Buildkite
      exit $test_status

    matrix:
      setup:
        architecture:
          - "CPU"
          # - "GPU"
        group:
          # - "ðŸ¦– poisson_solvers_2"
          - "ðŸ‡ unit"
          # - "ðŸ‘» abstract_operations"
          # - "ðŸ•Š poisson_solvers_1"
          # - "ðŸ¦¤ general_solvers"
          # - "ðŸŽ£ turbulence_closures"
          # - "ðŸ¦€ time_stepping_1"
          # - "ðŸ¦ˆ time_stepping_2"
          # - "ðŸ¦Ÿ time_stepping_3"
          # - "ðŸ« nonhydrostatic_regression"
          # - "ðŸ™ hydrostatic_free_surface"
          # - "ðŸ« tripolar_grid"
          # - "ðŸ¥‘ vertical_coordinate"
          # - "ðŸ™ˆ hydrostatic_regression"
          # - "ðŸ¦¢ shallow_water"
          # - "ðŸ³ simulation"
          # - "ðŸ‚ lagrangian_particles"
          # - "ðŸ§… multi_region"
          # - "ðŸ¦§ scripts"
          # - "ðŸ± xesmf"

    retry:
      automatic:
        - exit_status: 1
          limit: 1

  - label: "{{ matrix.architecture }} - {{ matrix.group }} tests"
    key: "tests_enzyme_reactant"
    depends_on: "init_enzyme"
    agents:
      queue: "Oceananigans-nautilus"
    command: |
      # Add matrix-specific environment variables
      if [[ "{{ matrix.architecture }}" == "CPU" ]]; then
        export CUDA_VISIBLE_DEVICES="-1"
        export TEST_ARCHITECTURE="CPU"
      else
        export CUDA_VISIBLE_DEVICES="0"
        export TEST_ARCHITECTURE="GPU"
      fi

      # Strip emoji for environment variable
      group="{{ matrix.group }}"
      export TEST_GROUP="\${group#* }"
      echo $TEST_GROUP

      # Run tests (but don't exit immediately so we can upload coverage even if tests fail)
      set +e
      julia +$JULIA_VERSION -O0 --color=yes --project --code-coverage=user -e 'using Pkg; Pkg.test(coverage="user")'
      test_status=$$?
      set -e

      # Sanity check: did we actually produce coverage?
      echo "Coverage files produced:" $$(find . -name "*.cov" | wc -l)
      find . -name "*.cov" | head -n 20 || true

      # Ship coverage files
      cd "$OCEANANIGANS_DIR"

      echo "PWD for coverage:"; pwd
      echo "Example cov files:"; find . -type f -name "*.cov" | head -n 20 || true

      tarball="coverage-${BUILDKITE_JOB_ID}.tgz"
      echo "Tarball will be: $tarball"

      # Create tarball directly from find output (newline-delimited)
      # This avoids --null / --files-from / covfiles.txt entirely.
      find . -type f -name "*.cov" -print > cov_list.txt
      echo "Coverage files found:" $(wc -l < cov_list.txt)
      head -n 20 cov_list.txt || true

      # If none, donâ€™t fail the step (but print why)
      if [ ! -s cov_list.txt ]; then
        echo "No .cov files found at tar time (but you printed some earlier)."
        exit 1
      fi

      tar -czf "$tarball" -T cov_list.txt

      # Upload single artifact
      buildkite-agent artifact upload "$tarball"

      # Preserve the original test result for Buildkite
      exit $test_status

    matrix:
      setup:
        architecture:
          - "CPU"
          - "GPU"
        group:
          # - "ðŸŽ­ reactant_2"
          # - "ðŸ‘º enzyme"
          - "ðŸ‘¹ reactant_1"

    retry:
      automatic:
        - exit_status: 1
          limit: 1

  #####
  ##### Blocking wait on tests and documentation
  #####

  - wait: ~
    continue_on_failure: true

  #####
  ##### Upload to Codecov
  #####

  - label: "ðŸ“Š Upload coverage to Codecov"
    agents:
      queue: "Oceananigans-nautilus"
    command: |
      # Make failures obvious
      set -e

      # Resolve paths once
      REPO="$OCEANANIGANS_DIR"
      OUT="${BUILDKITE_BUILD_CHECKOUT_PATH:-$PWD}"

      echo "REPO=$REPO"
      echo "OUT=$OUT"
      test -d "$REPO" || { echo "REPO dir missing"; exit 1; }
      test -d "$OUT"  || { echo "OUT dir missing"; exit 1; }

      # Build a deterministic file list using absolute find (no dependence on cd)
      cov_list="$OUT/cov_list.txt"
      tarball="$OUT/coverage-${BUILDKITE_JOB_ID:-nojobid}.tgz"

      find "$REPO" -type f -name "*.cov" > "$cov_list"

      echo "Coverage files found:" `wc -l < "$cov_list"`
      echo "First few:"
      head -n 20 "$cov_list" || true

      # Fail loudly if itâ€™s empty (it shouldn't be, given your earlier printout)
      if [ ! -s "$cov_list" ]; then
        echo "cov_list.txt is empty, despite earlier .cov output."
        echo "Debug: showing a fresh find sample:"
        find "$REPO" -type f -name "*.cov" | head -n 20 || true
        exit 1
      fi

      # Create tarball from the list.
      # Use tar's -T list, but paths in the list are absolute. That's fine.
      tar -czf "$tarball" -T "$cov_list"

      echo "Tarball created:" "$tarball"
      ls -lh "$tarball"

      # Upload from OUT (checkout) so Buildkite will definitely match it
      cd "$OUT"
      buildkite-agent artifact upload "$(basename "$tarball")"

  #####
  ##### Clean up
  #####

  - label: "ðŸ§¹ clean up environment"
    agents:
      queue: "Oceananigans-nautilus"
    commands:
      - "test -d $OCEANANIGANS_DIR && du -hs $OCEANANIGANS_DIR || true"
      - "test -d $OCEANANIGANS_DIR && rm -rf $OCEANANIGANS_DIR || true"
