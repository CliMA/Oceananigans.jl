struct TKEDissipationVerticalDiffusivity{TD, KE, ST, FT, DT} <: AbstractScalarDiffusivity{TD, VerticalFormulation, 2}
    tke_dissipation_equations :: KE
    stability_functions :: ST
    maximum_tracer_diffusivity :: FT
    maximum_tke_diffusivity :: FT
    maximum_dissipation_diffusivity :: FT
    maximum_viscosity :: FT
    minimum_tke :: FT
    negative_tke_damping_time_scale :: FT
    tke_dissipation_time_step :: DT
end

function TKEDissipationVerticalDiffusivity{TD}(tke_dissipation_equations::KE,
                                               stability_functions::ST,
                                               maximum_tracer_diffusivity::FT,
                                               maximum_tke_diffusivity::FT,
                                               maximum_dissipation_diffusivity::FT,
                                               maximum_viscosity::FT,
                                               minimum_tke::FT,
                                               negative_tke_damping_time_scale::FT, 
                                               tke_dissipation_time_step::DT) where {TD, KE, ST, FT, DT}

    return TKEDissipationVerticalDiffusivity{TD, KE, ST, FT, DT}(tke_dissipation_equations,
                                                                 stability_functions,
                                                                 maximum_tracer_diffusivity,
                                                                 maximum_tke_diffusivity,
                                                                 maximum_dissipation_diffusivity,
                                                                 maximum_viscosity,
                                                                 minimum_tke,
                                                                 negative_tke_damping_time_scale,
                                                                 tke_dissipation_time_step)
end

TKEDissipationVerticalDiffusivity(FT::DataType; kw...) =
    TKEDissipationVerticalDiffusivity(VerticallyImplicitTimeDiscretization(), FT; kw...)

const TDVD{TD} = TKEDissipationVerticalDiffusivity{TD} where TD
const TDVDArray{TD} = AbstractArray{<:TDVD{TD}} where TD
const FlavorOfTD{TD} = Union{TDVD{TD}, TDVDArray{TD}} where TD

"""
    TKEDissipationVerticalDiffusivity([time_discretization = VerticallyImplicitTimeDiscretization(),
                                      FT = Float64;]
                                      tke_dissipation_equations = TKEDissipationEquations(),
                                      stability_functions = ConstantStabilityFunctions(),
                                      maximum_tracer_diffusivity = Inf,
                                      maximum_tke_diffusivity = Inf,
                                      maximum_dissipation_diffusivity = Inf,
                                      maximum_viscosity = Inf,
                                      minimum_tke = 1e-9,
                                      negative_tke_damping_time_scale = 1minute,
                                      tke_dissipation_time_step = nothing)

Return the `TKEDissipationVerticalDiffusivity` turbulence closure for vertical mixing by
small-scale ocean turbulence based on the prognostic evolution of subgrid
Turbulent Kinetic Energy (TKE).

!!! note "TKEDissipationVerticalDiffusivity"
    `TKEDissipationVerticalDiffusivity` is new turbulence closure diffusivity. The default
    values for its free parameters are obtained from calibration against large eddy
    simulations. For more details please refer to [Wagner23catke](@cite).

    Use with caution and report any issues with the physics at https://github.com/CliMA/Oceananigans.jl/issues.

Arguments
=========

- `time_discretization`: Either `ExplicitTimeDiscretization()` or `VerticallyImplicitTimeDiscretization()`;
                         default `VerticallyImplicitTimeDiscretization()`.

- `FT`: Float type; default `Float64`.


Keyword arguments
=================

- `maximum_diffusivity`: Maximum value for tracer, momentum, and TKE diffusivities.
                        Used to clip the diffusivity when/if CATKE predicts
                        diffusivities that are too large.
                        Default: `Inf`.

- `minimum_tke`: Minimum value for the turbulent kinetic energy.
                 Can be used to model the presence "background" TKE
                 levels due to, for example, mixing by breaking internal waves.
                 Default: 1e-9.

- `negative_tke_damping_time_scale`: Damping time-scale for spurious negative values of TKE,
                                     typically generated by oscillatory errors associated
                                     with TKE advection.
                                     Default: 1 minute.

Note that for numerical stability, it is recommended to either have a relative short
`negative_turbulent_kinetic_energy_damping_time_scale` or a reasonable
`minimum_turbulent_kinetic_energy`, or both.
"""
function TKEDissipationVerticalDiffusivity(time_discretization::TD = VerticallyImplicitTimeDiscretization(),
                                           FT = Float64;
                                           tke_dissipation_equations = TKEDissipationEquations(),
                                           stability_functions = ConstantStabilityFunctions(),
                                           maximum_tracer_diffusivity = 1,
                                           maximum_tke_diffusivity = Inf,
                                           maximum_dissipation_diffusivity = Inf,
                                           maximum_viscosity = Inf,
                                           minimum_tke = 1e-9,
                                           negative_tke_damping_time_scale = 1minute,
                                           tke_dissipation_time_step = nothing) where TD

    return TKEDissipationVerticalDiffusivity{TD}(tke_dissipation_equations,
                                                 stability_functions,
                                                 convert(FT, maximum_tracer_diffusivity),
                                                 convert(FT, maximum_tke_diffusivity),
                                                 convert(FT, maximum_dissipation_diffusivity),
                                                 convert(FT, maximum_viscosity),
                                                 convert(FT, minimum_tke),
                                                 convert(FT, negative_tke_damping_time_scale),
                                                 tke_dissipation_time_step)
end

function with_tracers(tracer_names, closure::FlavorOfTD)
    :e ∈ tracer_names && :ϵ ∈ tracer_names ||
        throw(ArgumentError("Tracers must contain :e and :ϵ to represent turbulent kinetic energy " *
                            "for `TKEDissipationVerticalDiffusivity`."))

    return closure
end

#####
##### Diffusivities and diffusivity fields utilities
#####

function DiffusivityFields(grid, tracer_names, bcs, closure::FlavorOfTD)

    default_diffusivity_bcs = (κu = FieldBoundaryConditions(grid, (Center, Center, Face)),
                               κc = FieldBoundaryConditions(grid, (Center, Center, Face)),
                               κe = FieldBoundaryConditions(grid, (Center, Center, Face)),
                               κϵ = FieldBoundaryConditions(grid, (Center, Center, Face)))

    bcs = merge(default_diffusivity_bcs, bcs)

    κu = ZFaceField(grid, boundary_conditions=bcs.κu)
    κc = ZFaceField(grid, boundary_conditions=bcs.κc)
    κe = ZFaceField(grid, boundary_conditions=bcs.κe)
    κϵ = ZFaceField(grid, boundary_conditions=bcs.κϵ)
    Le = CenterField(grid)
    Lϵ = CenterField(grid)

    # Note: we may be able to avoid using the "previous velocities" in favor of a "fully implicit"
    # discretization of shear production
    u⁻ = XFaceField(grid)
    v⁻ = YFaceField(grid)
    previous_velocities = (; u=u⁻, v=v⁻)

    # Secret tuple for getting tracer diffusivities with tuple[tracer_index]
    _tupled_tracer_diffusivities = Dict{Symbol, Any}(name => κc for name in tracer_names)
    _tupled_tracer_diffusivities[:e] = κe
    _tupled_tracer_diffusivities[:ϵ] = κϵ
    _tupled_tracer_diffusivities = NamedTuple(name => _tupled_tracer_diffusivities[name]
                                              for name in tracer_names)

    _tupled_implicit_linear_coefficients = Dict{Symbol, Any}(name => ZeroField() for name in tracer_names)
    _tupled_implicit_linear_coefficients[:e] = Le
    _tupled_implicit_linear_coefficients[:ϵ] = Lϵ
    _tupled_implicit_linear_coefficients = NamedTuple(name => _tupled_implicit_linear_coefficients[name]
                                                      for name in tracer_names)

    return (; κu, κc, κe, κϵ, Le, Lϵ, previous_velocities,
            _tupled_tracer_diffusivities, _tupled_implicit_linear_coefficients)
end        

@inline viscosity_location(::FlavorOfTD) = (c, c, f)
@inline diffusivity_location(::FlavorOfTD) = (c, c, f)

function compute_diffusivities!(diffusivities, closure::FlavorOfTD, model; parameters = :xyz)

    arch = model.architecture
    grid = model.grid
    velocities = model.velocities
    tracers = model.tracers
    buoyancy = model.buoyancy
    clock = model.clock
    top_tracer_bcs = NamedTuple(c => tracers[c].boundary_conditions.top for c in propertynames(tracers))

    if isfinite(model.clock.last_Δt) # Check that we have taken a valid time-step first.
        # Compute e at the current time:
        #   * update tendency Gⁿ using current and previous velocity field
        #   * use tridiagonal solve to take an implicit step
        time_step_tke_dissipation_equations!(model)
    end

    # Update "previous velocities"
    u, v, w = model.velocities
    u⁻, v⁻ = diffusivities.previous_velocities
    parent(u⁻) .= parent(u)
    parent(v⁻) .= parent(v)

    launch!(arch, grid, parameters,
            compute_TKEDissipation_diffusivities!,
            diffusivities, grid, closure, velocities, tracers, buoyancy)

    return nothing
end

@kernel function compute_TKEDissipation_diffusivities!(diffusivities, grid, closure::FlavorOfTD,
                                                       velocities, tracers, buoyancy)
    i, j, k = @index(Global, NTuple)

    # Ensure this works with "ensembles" of closures, in addition to ordinary single closures
    closure_ij = getclosure(i, j, closure)

    # Note: we also compute the TKE diffusivity here for diagnostic purposes, even though it
    # is recomputed in time_step_turbulent_kinetic_energy.
    κu★ = κuᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
    κc★ = κcᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
    κe★ = κeᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)
    κϵ★ = κϵᶜᶜᶠ(i, j, k, grid, closure_ij, velocities, tracers, buoyancy)

    κu★ = mask_diffusivity(i, j, k, grid, κu★)
    κc★ = mask_diffusivity(i, j, k, grid, κc★)
    κe★ = mask_diffusivity(i, j, k, grid, κe★)
    κϵ★ = mask_diffusivity(i, j, k, grid, κϵ★)

    @inbounds begin
        diffusivities.κu[i, j, k] = κu★
        diffusivities.κc[i, j, k] = κc★
        diffusivities.κe[i, j, k] = κe★
        diffusivities.κϵ[i, j, k] = κϵ★
    end
end

@inline function turbulent_kinetic_energyᶜᶜᶜ(i, j, k, grid, closure, tracers)
    eᵐⁱⁿ = closure.minimum_tke
    eⁱʲᵏ = @inbounds tracers.e[i, j, k]
    return max(eᵐⁱⁿ, eⁱʲᵏ)
end

@inline function maximum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
    FT = eltype(grid)
    d = depthᶜᶜᶠ(i, j, k, grid)
    N² = ℑbzᵃᵃᶜ(i, j, k, grid, ∂z_b, buoyancy, tracers)
    N²⁺ = clip(N²)
    eⁱʲᵏ = turbulent_kinetic_energyᶜᶜᶜ(i, j, k, grid, closure, tracers)
    ℓst = ifelse(N²⁺ == 0, FT(Inf), sqrt(eⁱʲᵏ / N²⁺))
    ℓmin = min(grid.Lz, ℓst)
    return sqrt(eⁱʲᵏ)^3 / ℓmin
end

@inline function minimum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
    eᵐⁱⁿ = closure.minimum_tke
    ℓmax = grid.Lz
    return sqrt(eᵐⁱⁿ)^3 / ℓmax
end

@inline function dissipationᶜᶜᶜ(i, j, k, grid, closure, tracers, buoyancy)
    ϵᵐᵃˣ = maximum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
    ϵᵐⁱⁿ = minimum_dissipation(i, j, k, grid, closure, tracers, buoyancy)
    ϵⁱʲᵏ = @inbounds tracers.ϵ[i, j, k]
    return clamp(ϵⁱʲᵏ, ϵᵐⁱⁿ, ϵᵐᵃˣ)
end

@inline function κuᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
    e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
    ϵ  = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
    ςu = momentum_stability_function(i, j, k, grid, closure.stability_functions, velocities, tracers, buoyancy)
    κu = ςu * e² / ϵ
    κu_max = closure.maximum_viscosity
    return min(κu, κu_max)
end

@inline function κcᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
    e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
    ϵ  = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
    ςc = tracer_stability_function(i, j, k, grid, closure.stability_functions, velocities, tracers, buoyancy)
    κc = ςc * e² / ϵ
    κc_max = closure.maximum_tracer_diffusivity
    return min(κc, κc_max)
end

@inline function κeᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
    e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
    ϵ  = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
    ςe = tke_stability_function(i, j, k, grid, closure.stability_functions, velocities, tracers, buoyancy)
    κe = ςe * e² / ϵ
    κe_max = closure.maximum_tke_diffusivity
    return min(κe, κe_max)
end

@inline function κϵᶜᶜᶠ(i, j, k, grid, closure::TDVD, velocities, tracers, buoyancy)
    e² = ℑzᵃᵃᶠ(i, j, k, grid, ϕ², turbulent_kinetic_energyᶜᶜᶜ, closure, tracers)
    ϵ  = ℑzᵃᵃᶠ(i, j, k, grid, dissipationᶜᶜᶜ, closure, tracers, buoyancy)
    ςϵ = dissipation_stability_function(i, j, k, grid, closure.stability_functions, velocities, tracers, buoyancy)
    κϵ = ςϵ * e² / ϵ
    κϵ_max = closure.maximum_dissipation_diffusivity
    return min(κϵ, κϵ_max)
end

@inline viscosity(::FlavorOfTD, diffusivities) = diffusivities.κu
@inline diffusivity(::FlavorOfTD, diffusivities, ::Val{id}) where id = diffusivities._tupled_tracer_diffusivities[id]
    
#####
##### Show
#####

function Base.summary(closure::TDVD)
    TD = nameof(typeof(time_discretization(closure)))
    return string("TKEDissipationVerticalDiffusivity{$TD}")
end

