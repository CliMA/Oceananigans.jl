Differentiation and interpolation operators

The geometry of the staggerd grid used by Oceananigans (the Arakawa C-grid)
is (in one dimension) shown below

face   cell   face   cell   face

        i-1            i
         ↓             ↓
  |      ×      |      ×      |
  ↑             ↑             ↑
 i-1            i            i+1

Difference operators are denoted by a `δ` (`\delta`). Calculating the difference
of a cell-centered quantity ϕ at cell i will return the difference at face i

    δϕᵢ = ϕᵢ - ϕᵢ₋₁

and so this operation, if applied along the x-dimension, is denoted by `δx_faa`.

The difference of a face-centered quantity u at face i will return the difference
at cell i

    δuᵢ = uᵢ₊₁ - uᵢ

and is thus denoted `δx_caa` when applied along the x-dimension.

The three characters at the end of the function name, `faa` for example, indicates that
the output will lie on the cell faces in the x-dimension but will remain at their original
positions in the y- and z-dimensions. Thus we further identify this operator by `_faa`
where the `a` stands for any as the location is unchanged by the operator and is determined
by the input.

As a result the interpolation of a quantity ϕ from a cell i to face i
(this operation is denoted "ϊx_faa" in the code below) is

    ϊx_faa(ϕ)ᵢ = (ϕᵢ + ϕᵢ₋₁) / 2

Conversely, the interpolation of a quantity u from a face i to cell i is given by

    ϊx_caa(u)ᵢ = (uᵢ₊₁ + uᵢ) / 2

The `ϊ` (`\iota\ddot`) symbol indicates that an interpolation is being performed.
`ϊx`, for example, indicates that the interpolation is performed along the x-dimension.
The three following characters in the interpolation function name indicate the
position that is being interpolated to following the same convention used for difference
operators.


Implementation of walls

The vertical difference and interpolation operators contain branching statements to treat
the top face or bottom cell differently. Here we explain why that is.

Recall that for a staggered grid of size N^3, there are N cells and N+1 faces in each
dimension. Oceananigans stores an array of size Nx*Ny*Nz for each velocity and tracer
field. For tracers it stores the average value of the tracer over the cell, and for
velocities it stores the average velocity over the cell face, but only for the first N
faces so values at the last face or beyond the faces must be inferred or implies.

We will illustrate how walls are implemented in the vertical.

The `δz_aaf` function computes the difference of a cell-centered field f at the faces.
To compute the difference at the first face it would need to know the value of the
field f above the first face but the field does not exist there. Thus, to impose the
no-flux boundary condition at the surface we choose δz_faa = 0 at k=1 which is the same
as assuming that f(0) = f(1), or that the gradient of f goes to zero at the surface so
that no flux is generated through the surface.

    face 1      ---------   <-- δz_aaf = 0 at the surface
    cell 1          x       <-- f(1)
    face 2         ---
    cell 2          x       <-- f(2)


The `δz_aac` function computes the difference of a face-centered field f at the cell centers
(denoted x in the diagrams). To compute the difference at cell center Nz, we need to know the
value of f at face Nz+1, which we do not store. But we want the difference or gradient to go
to zero at face Nz+1 to impose the no-flux boundary condition. To impose this, we set the
value at face Nz to be the same as the value at face Nz, so that the gradient is zero going
toward the bottom. This is equivalent to setting f(Nz+1) = 0.

    cell Nz-1       x
    face Nz        ---      <-- f(Nz)
    cell Nz         x       <-- δz_aac = f(Nz) at the bottom cell
    face Nz+1   ---------   <-- f(Nz+1) = 0
    

The `ϊz_aaf` function interpolates the value of a cell-centered field f onto the cell faces.
Again, to interpolate onto face 1 we would need to know the value of f above the surface,
which we don't. We can consistently impose that the gradient goes to zero at the surface and
thus impose that the interpolation of f at face 1 is the value of f at cell center 1.

    face 1      ---------   <-- ϊz_aaf = f(1) at the surface
    cell 1          x       <-- f(1)
    face 2         ---
    cell 2          x       <-- f(2)


The `ϊz_aac` function interpolates the value of a face-centered field f onto the cell-centers.
Again, to interpolate onto cell center Nz, we would need to know the value of f at face Nz+1,
which we don't. We can consistently impose that the gradient goes to zero at the bottom and
thus impose that the interpolation of f at cell Nz is f(Nz)/2.

    cell Nz-1       x
    face Nz        ---      <-- f(Nz)
    cell Nz         x       <-- ϊz_aac = f(Nz)/2 at the bottom cell
    face Nz+1   ---------   <-- f(Nz+1) = 0
